# Implement your install deployment tasks here
# -------------------------------------------------

- name: create ec2 instance
  amazon.aws.ec2_instance:
    instance_type: "{{ aws_vm_instance_type }}"
    image_id: "{{ aws_vm_image_id }}"
    vpc_subnet_id: "{{ subnet.subnet.id }}"
    security_group: "{{ security_group.group_id }}"
    key_name: "{{ ssh_public_key_name }}"
    network_interfaces:
      - assign_public_ip: true
    volumes:
      - device_name: /dev/sda1
        ebs:
          volume_size: "{{ aws_vm_boot_disk_size }}"
          delete_on_termination: true
      - device_name: /dev/sdb
        ebs:
          volume_size: "{{ aws_vm_data_disk_size }}"
          volume_type: gp3
          delete_on_termination: true
    tags:
      Name: "{{ instance_name }}"
    wait: yes
    count: 1
    aws_access_key: "{{ aws_access_key_id }}"
    aws_secret_key: "{{ aws_secret_access_key }}"
    region: "{{ aws_default_region }}"
  register: ec2

- name: set public ip and public dns
  set_fact:
    instance_public_ip: "{{ ec2.instances[0].public_ip_address }}"
    instance_public_dns: "{{ ec2.instances[0].public_dns_name }}"
  when: ec2.instances | length > 0

- name: wait for ssh to be available on the new instance
  wait_for:
    host: "{{ instance_public_ip }}"
    port: 22
    delay: 10
    timeout: 300
    state: started

- name: add host key to known_hosts
  known_hosts:
    name: "{{ instance_public_ip }}"
    key: "{{ lookup('pipe', 'ssh-keyscan -H ' + instance_public_ip) }}"
    state: present

# mount the data volume

- name: mount the data volume
  delegate_to: "{{ instance_public_ip }}"
  become: true
  vars:
    ansible_user: "{{ instance_default_user }}"
    ansible_ssh_private_key_file: "{{ public_key_dir }}/{{ instance_key_name }}"
    ansible_ssh_common_args: "-o StrictHostKeyChecking=no"
  block:
    - name: list available block devices
      delegate_to: "{{ instance_public_ip }}"
      become: true
      command: lsblk
      register: block_devices

    - name: show available block devices
      debug:
        var: block_devices.stdout_lines

    - name: find the root device
      delegate_to: "{{ instance_public_ip }}"
      become: true
      shell: lsblk -rno NAME,MOUNTPOINT | grep '/$' | cut -d' ' -f1 | sed 's/p\?[0-9]*$//'
      register: root_device

    - name: find the additional storage device
      delegate_to: "{{ instance_public_ip }}"
      become: true
      shell: |
        # Get all disk devices
        ALL_DISKS=$(lsblk -rno NAME,TYPE | grep disk | awk '{print $1}')
        # Get the root device (trimmed of whitespace)
        ROOT_DEVICE=$(echo "{{ root_device.stdout }}" | tr -d '[:space:]')
        # Filter out the root device
        for disk in $ALL_DISKS; do
          # Trim whitespace from disk name
          disk_trimmed=$(echo "$disk" | tr -d '[:space:]')
          if [ "$disk_trimmed" != "$ROOT_DEVICE" ]; then
            echo "$disk_trimmed"
            break
          fi
        done
      register: additional_device_result

    - name: set additional device name
      set_fact:
        additional_device_name: "{{ additional_device_result.stdout }}"
      when: additional_device_result.stdout != ""

    - name: show additional device found
      debug:
        var: additional_device_name

    - name: create filesystem on additional storage device
      delegate_to: "{{ instance_public_ip }}"
      become: true
      filesystem:
        fstype: ext4
        dev: "/dev/{{ additional_device_name }}"
        force: no
      when: additional_device_name is defined

    - name: create mount point directory
      delegate_to: "{{ instance_public_ip }}"
      become: true
      file:
        path: "{{ volume_mount_point }}"
        state: directory
        mode: '0755'

    - name: mount additional storage device
      delegate_to: "{{ instance_public_ip }}"
      become: true
      mount:
        path: "{{ volume_mount_point }}"
        src: "/dev/{{ additional_device_name }}"
        fstype: ext4
        state: mounted
        opts: defaults
      when: additional_device_name is defined

    - name: set proper ownership on mount point
      delegate_to: "{{ instance_public_ip }}"
      become: true
      file:
        path: "{{ volume_mount_point }}"
        owner: root
        group: root
        mode: '0755'
